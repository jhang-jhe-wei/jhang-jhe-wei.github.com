---
title:  "Ruby 物件導向程式實踐心得"
createdAt:   '2023-07-13T00:00:00Z'
categories: Note
description: 此篇文章是紀錄 Ruby 物件導向程式實踐的心得，此篇文章的目的不在於教學，而是記錄我目前對於 OOP 的理解。
---
# Ruby 物件導向程式實踐心得

此篇文章是紀錄 Ruby 物件導向程式實踐的心得，此篇文章的目的不在於教學，而是記錄我目前對於 OOP 的理解。

## 物件導向程式設計

物件導向程式設計看起來很艱深，但本質上就是安排各種元件(Object)和其之間的訊息(Message)，並讓其可以應付未來的變更，或者說整個物件導向程式設計就是在管理依賴關係，為此出現了許多概念和模式，如 SOLID、DRY和各種 Design Pattern，不過一知半解的強硬套用反而會造成失敗的設計，正確做法應是依照目前的能力和時間表做出馬上能得到效益的設計，而為了做出完美的設計反而會限制了未來的變化，尤其是在對整個應用程式資訊還不足的情況下。

## 單一職責的類別

物件導向語言和程序性語言最大的不同在於資料和行為之間息息相關，為此我們會將相關的資料和行為放在同一個類別中，提高「內聚」。

一個類別知道得越多，代表依賴的越多，那它就越難重複使用，因為很容易牽一髮動全身，遵守單一職責的類別容易修改且不用擔心後果，但我們該如何判斷類別是否具有單一職責？

我們可以藉由把類別當成一個人來提問：

> 想像有一個書店 BookStore 類別，並向他提問……

書店先生，請問你有賣 *Ruby 物件導向程式實踐* 這本書嗎？
: 有

書店先生，請問你的推薦的書籍？
: *Ruby 物件導向程式實踐*

書店先生，請問你有提供什麼食物？
: ???
>

在這個例子中我們的常識可以知道食物跟書店並沒有太大的關係，若書店可以回應有什麼食物，則可以判斷書店可能包含了多種的職責。

假如今天我們從書店改變商業模式成為混合咖啡廳，書店需要回應點餐這個行為，我們該怎麼做呢?可以用一堆華麗的繼承技巧堵死自己的退路，也可以靠著加一個 method 就完成需求

前者破壞這個類別的職責，後者則是 over-engineering，但我們可以選擇一個折衷的方法，既可以區分類別的職責，也可以避免 over-engineering，方法是建立一個 `Restaurant` 類別，將點餐的行為放在其中，在初期我們甚至可以直接在 `BookStore`  裡定義這個類別，就像這樣：

```ruby
class BookStore
	attr_reader :restaurant
	class Restaurant
		def order_meal(arg)
			...
		end
	end

	def initialize(books_attrs, restaurant_attrs)
		@restaurant = Restaurant.new(restaurant_attrs)
	end

	def order_meal(arg)
		restaurant.order_meal(arg)
	end
end
```

雖然經由 BookStore 點餐還是有點怪怪的，但我們至少清楚的區分其職責。

上一章有提到設計取決於能力和時間表，能力代表的是現在對於整體資訊的掌握，而時間表則是做這個設計花費的成本符不符合效益，因為只要未來有變化就沒有完美的設計，設計應是為了日後能繼續設計和面對變化而存在，所以你該在保證日後方便修改的前提下花最小的資源做完。

## 撰寫擁抱變化的程式碼

我們目前寫的程式碼應能輕鬆地應付日後的修改，DRY 就是一個很實用的原則，在寫 Ruby 時可以按照以下一些方法：

1. 依賴於行為而非資料
2. 隱藏資料結構

第一點有個例子是 *使用 `attr_reader` 取代直接讀取實體變數*  ，這是因為日後實體變數需要進行轉型或轉換時，可以直接將 `attr_reader` 改為 method，並在其中編寫相應的程式碼而不用修改全部的實體變數。

第二點則是指 Array 中不同的 Index 代表不同的意義，如：

```ruby
Book[0] # Name
Book[1] # author
Book[2] # publish year
```

若今日 Array 的結構發生變化，如變化成這樣：

```ruby
Book[0] # Name
Book[1] # version
Book[2] # author
Book[3] # publish year
```

那對於之後的程式碼根本是惡夢，但我們可以使用 `BookModel = Struct.new(:name, :author, :publish_year)` 將 Array 修改順序的傷害降到最低。

## 管理依賴關係

對於任何行為，物件會有三種情況

1. 自己本身知道如何回應
2. 經由繼承回應
3. 藉由別的物件回應

這節特別討論第三點

> 知道越多，代表依賴越重，當需求出現變化時，修改程式碼的成本會變高
>

我以前曾經寫出這種程式碼：

```ruby
class ColumnRebarFormModel
  def initialize(hash)
    @layer = hash[:layer]
    @instance_name = hash[:instance]
    @is_only_line = hash[:lineonly]
    @cover = hash[:side_cover].to_f.cm
    @stirrup = Stirrup.new(hash)
    @steel_bar = SteelBar.new(hash)
    @top = Bound.new(hash[:top_offset], hash[:top_cover])
    @bottom = Bound.new(hash[:bottom_offset], hash[:bottom_cover])
  end
 ......
end
```

在以上的程式碼出現了幾個依賴情形

1. `ColumnRebarFormModel` 知道 `Bound` 的參數順序
2. `ColumnRebarFormModel` 知道有 `Stirrup`、 `Bound` 等的類型，也就是對於這個具體的類別產生依賴

想像一下今天改了`Stirrup` 的名字或是調整了 `Bound` 的參數順序將會造成怎樣的後果。

要移除這些依賴可以做以下幾件事：

1. 使用 hash 或是 keyword argument 取代參數有順序關係的方法，且此方法還可以搭配 `fetch` 或是 `||` 給予預設值，甚至直接 merge 一組預設 hash，這種方式在參數越多越複雜時越能體現其好處。
    1. 若今天使用的方法無法讓你修改，則可以考慮用 `Factory` 的方式包裝，例如 `Bound` 是個不可修改的類別，則我們可以用此方式包裝其 `#new`

    ```ruby
    module BoundWrapper
    	def self.build(hash)
    		Bound.new(hash[:offset], hash[:cover])
    	end
    end

    BoundWrapper.build({
    	offset: 20.cm,
    	cover: 10.cm
    })
    ```

    雖然看起來有點白作工，但藉由這個中間層可以將 Bound 的變化成本限制在 `[BoundWrapper.build](http://BoundWrapper.build)` 之中。

2. 使用依賴注入避免相依於具體的類別，因為我們關心的只有這個物件能不能回應某個行為

依賴注入可以延伸到另一個觀念「反轉依賴」，導致依賴的方向是可以自由決定的，我們可以得知幾個原則：

1. 應*依賴於不容易變化的類別*
2. *具體比抽象更容易變化*
3. *減少依賴將能夠降低修改的成本*

## 建立靈活的介面

1. Domain object 很容易發現，例如：使用者、商家，但之間傳遞的訊息才是構成整個 Application 的核心，而訊息藉由介面在物件中傳遞
2. 可以藉由順序圖了解訊息的傳遞，可以發現隱藏的物件和設計公共介面
3. 用「要什麼」取代「如何要」，專注於結果，並且可以使用依賴注入來達成上下文獨立
4. 當出現 chaining method 時很可能違反「 迪米特法則」，「 迪米特法則」是一套能帶來鬆耦合的守則，表象解是用 delegation，但本質上應該是目前程式碼處於「如何要」的狀態

## 使用鴨子類型技巧降低成本

1. 當出現「我知道你是誰，並且我知道你能做什麼」時，通常都可以用鴨子型別變成「我知道你能做什麼」
2. 當出現以下架構時，通常可以使用鴨子型別降低修改成本
    1. case…when
    2. is_a?
3. 具體容易釐清但是修改成本高，抽象難懂但是可以輕易擴充
    1. 具體 → prepare_food, prepare_cars
    2. 抽象 → prepare
4. 基本資料類別也能建立新的抽象方法，這稱為「Monkey patch」

## 藉由繼承取得行為

1. 提升抽象而並非下放具體，白話文來說應把子類別的程式碼抽取共同的部分放到父類別
2. 可以使用 `raise NotImplementedError` 建立 Template 類別
3. 使用 hook 使子類別和父類別解耦，避免使用 `super`

## 使用模組共用角色行為

1. [里氏替換原則](https://www.jyt0532.com/2020/03/22/lsp/)的進一步解釋，包含何時該用繼承

## 組合物件

1. 組合(composition)和聚合(aggregate)的差別
    1. 組合代表的是什麼含有什麼
    2. 聚合是一種特殊的組合，被含有的東西含有其自己的獨立生命
2. 組合、模組和繼承的比較
    1. 繼承：代表的是「is-a」，自動委派(delegation)訊息是繼承最大的特點，若使用得宜，在程式碼的可用性、合理性和典範性的表現上都很突出，因為繼承導致非常強的依賴關係，在大部分的情況下應首先選擇組合。
    2. 模組：代表的是「behavior likes a」，專注的是角色共用的這件事，如：可調度、可列印等等的角色行為
    3. 組合：代表的是「has-a」顧名思義，組合就是將不同功能的小物件組合起來，藉由定義相同的介面，可以自由的抽換其中的小物件，適應各種不同的變化
    4. 模組：代表的是「behavior likes a」，模組在乎的是共用角色的部分，

## 設計節省成本的測試

1. A 物件的輸出等於 B 物件的輸入，A 物件的測試只需測到 A 物件的輸出即可
2. 測試的輸出分為兩種，查詢和命令
3. 減少重複或重疊的測試
4. 測試之所以難寫，很大程度跟主程式的寫法有關係，如依賴注入與替身的關係
5. BDD 和 TDD 都是先寫測試再實作，差別在於著重點：
    1. BDD: 從外而內
    2. TDD: 從內而外
6. 使用 shared_test 共用角色行為
7. 永遠不需要測試私有方法，若私有方法過於龐大，可以考慮抽取成一個新的物件，並增加該物件的測試
8. 測試繼承時，若父類別為抽象，可以建立一個專用於測試的子類別
9. 避免測試與主程式脫離，如某物件的 method 已經更名了，但由於 test 中是用 Stub 導致測試依然通過，此時如果該物件已有 `expect_response_to(:method)` 就可以即時發現原因
10. 先寫測試的好處在於可以強迫自己使用可重複使用性的程式碼
11. 如果建立真物件不會太麻煩的話，可以考慮直接注入真物件，而並非建立一個偽物件
